#### 前端优化的目的是什么?
- 从用户角度而言, 优化能够让页面加载更快、对用户操作响应更及时, 能够给用户提供更友好的体验.
- 从服务商角度而言, 优化能够减少页面请求数、或者减少请求所占带宽,能节省可观的资源.

#### 网络方面
**减少HTTP请求**
> 主要是优化JS、CSS和图片资源    
- CSS Spries 合并图片(雪碧图的使用)
- 合并js、css文件 
- 内联图片(data: URL模式) base64

**减少资源体积**
- gzip压缩(主要正对HTML文件)
- js混淆(压缩、丑化去除注释和空白符)
- css压缩(去掉数组和空白符)
- 图片压缩

**缓存**
- DNS缓存
- CDN部署与缓存(静态资源文件的分发网络, 加快获取速度)
- http缓存(给资源设定缓存时间,防止在有效的缓存时间内对资源的重复下载)

**移动端优化**
- 使用长cache, 减少重定向
- 首屏优化, 保证首屏加载数据小于14kb
- 不滥用web字体

#### 渲染和DOM操作方面
**优化网页渲染**
- CSS文件防止头部, JS文件防止尾部或者异步加载
- 尽量避免内联样式(可以有效的减少html的提交)

**DOM操作优化**
- 避免在document上直接进行频繁的DOM操作
- 使用className代替大量的内联样式修改
- 对复杂的UI元素, 设置position为absolute或fixed
- 尽量使用css动画
- 使用requestAnimationFrame代替setInterval操作
- 适当使用canvas
- 尽量减少css表达式的使用
- 使用事件代理

**操作细节注意**
- 避免图片或frame使用空src
- 在css属性为0时, 去掉单位
- 禁止图片缩放
- 正确的css前缀的使用
- 移除空的css规则
- 对于css中可以继承的属性, 尽量使用继承, 少一点设置
- 缩短css选择器, 多使用伪元素等帮助定位

**移动端优化**
- 长列表滚动优化(IOS尽量使用局部滚动, android尽量使用全局滚动,需要给body添加-webkit-overflow-scrolling: touch来优化移动端的滚动)
- 函数防抖和函数节流(设计到滚动等频繁触发的DOM事件, 需要做好防抖和节流的工作, 限制函数的执行频次, 以优化函数触发频繁过高导致的响应速度跟不上触发频率,出现延迟、假死、卡顿的现象)  
  函数防抖: 当调用动作过n毫秒后, 才会执行该动作, 若在这n毫秒内又调用此动作将重新计算执行时间;  
  函数节流: 预先设定一个执行周期, 当调用动作的时刻大于等于执行周期执行该周期, 然后进入下一个新周期;
- 使用touchstart、touchend代替click
- HTML的vviewport设置(可以防止页面的缩放)
- 开启GPU渲染加速  
  GPU: Graphics Processing Unit, 是一种硬件加速方式

#### 数据方面
**图片加载处理**
- 图片预加载  
  预加载的寓意就是体检加载内容. 图片预加载往往会被用在图片资源比较大, 即时加载时会导致很长的等待过程时, 才会被使用.
- 图片懒加载  
  只加载可视区的资源, 其他资源是随着用户的滚动而显示.   
  常见的图片懒加载的方式是: 最初给图片的src设置一个比较简单的图片, 然后将图片的真实地址设置给自定义的属性, 做一个占位, 然后给图片设置监听事件, 一旦图片达到可视范围, 就从自定义属性中获取出真实地址并赋给src进行加载.
- 首屏加载时进度条显示

**异步请求的优化**
- 使用正常的json数据格式进行交互
- 部分常用的数据缓存
- 数据埋点和统计 





























